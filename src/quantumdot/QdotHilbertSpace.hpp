#ifndef _QDOT_HILBERT_SPACE_HPP_
#define _QDOT_HILBERT_SPACE_HPP_

//
// Copyright (c) 2008 Simen Kvaal
//
// This file is part of OpenFCI.
//
// OpenFCI is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// OpenFCI is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with OpenFCI. If not, see <http://www.gnu.org/licenses/>.
//

#include <cassert>
#include <vector>
#include "Slater.hpp"

/**
 * \file QdotHilbertSpace.hpp
 * \author Simen Kvaal
 * \date 10-7-2008
 * 
 * \brief Hilbert space and single particle spaces for the quantum dot system.
 *
 */

namespace quantumdot {

/// \brief This struct defines a collection of quantum numbers for a
/// single-particle state.
///
/// Its purpose is to hold the quantum numbers N, m and sigma, and the
/// corresponding SP orbital number alpha.  By building a
/// std::vector<quantum_numbers> it becomes easier to loop over the SP
/// basis, compute properties of Slater determinants et.c.
typedef struct 
{
    // Quantum numbers.
    int sigma;       ///< Spin projection;  0 (down) or 1 (up)
    int m;           ///< Angular momentum.
    int n;           ///< Radial quantum number; >= 0.

    // Dependent numbers
    int N;           ///< Shell number; N == 2*n + |m|.
    int alpha;       ///< Orbital number. alpha == (N*(N+2)+m)/2
} quantum_numbers;


/// \brief Hilbert space for a quantum dot system, at a given spin projection Sz and angular momentum M.
///
/// This class contains:
/// - A suffiently large single particle basis (SP basis); using std::vector<quantum_numbers>
/// - Many-body basis of Slater determinants (SD basis)
/// - Generation of both.
class QdotHilbertSpace
{
  private:
    int R;                      ///< Hilbert space energy cut parameter.
    bool use_energy_cut;        ///< Whether or not to use an energy cut (direct product otherwise).
    int Sz;                     ///< 2*Sz, Total spin projection
    int A;                      ///< Number of particles in system
    int S;                      ///< 2*s, the total spin.
    int M;                      ///< Total orbital angular momentum
    
    std::vector<manybody::Slater> sd_basis; ///< Basis of Slater determinants. Generated by generateBasis().

    std::vector<quantum_numbers> qnumbers; ///< Holds all 1-particle quantum numbers and orbital numbers needed for the complete space
    int n_orbitals;              ///< Number of one particle orbitals in system.

  protected:
    /// \brief Builds quantum number vector qnumbers. Also sets n_orbitals.
    void buildSPBasis();
  public:
    /// \brief Let the outside world be able to obtain the single particle basis information
    /// \return Reference to qnumbers
    std::vector<quantum_numbers>& getSPBasis()
    {
      return qnumbers;
    }

    /// \brief Default constructor. Trivial initialization of some members.
    QdotHilbertSpace()
    {
      R = 0;
      use_energy_cut = false;
      Sz = 0;
      A = 0;
      S = 0;
      M = 0;
    }
    /// \brief Set number of particles.
    /// \param the_A    The number of particles
    void setParticles(int the_A)
    {
      A = the_A;
      assert(A >= 0);
    }
    /// \brief Set total angular momentum
    /// \param the_M   The total angular momentum.
    void setAngmom(int the_M)
    {
      M = the_M;
    }
    /// \brief Assign spin quantum numbers Sz and S.
    /// Set number of particles first.
    /// 
    /// \param the_Sz   The value for Sz
    /// \param the_S    The value for S. Checked against A and Sz.
    void setSpinValues(int the_Sz, int the_S)
    {
      Sz = the_Sz;
      S = the_S;
      assert(S >= abs(Sz));
      assert((S <= A) || (A == 0));
    }
    /// \brief Set the Hilbert space parameters, then build single particle basis.
    ///
    /// \param the_R                The value for R.
    /// \param the_use_energy_cut   Shall we use energy cut or direct product space?
    void setHilberSpaceParameters(int the_R, bool the_use_energy_cut)
    {
      R = the_R;
      assert(R>=0);
      use_energy_cut = the_use_energy_cut;
      buildSPBasis(); // build quantum number structure.
    }
    /// \brief Generate the basis of Slater determinants using a rather involved algorithm.
    void generateSDBasis();

    /// \brief Generate the basis of Slater determinants using naive, brute force method.
    ///
    /// This seems to take too long for A=5, 6 particles compared to the "smart" method.
    void generateSDBasisBruteForce();

    /// \brief Constraint function used in generateSDBasisBruteForce().
    bool constraint(const std::bitset<SLATER_BITS>& phi0)
    {
      using namespace std;
      using namespace manybody;


      Slater phi;
      phi = phi0;

      int up, down;
      phi.count_evenodd(up, down);

      // check that spin projection is correct
      if (up - down != Sz)
	return false;
  
      int theM = 0;
      int theN = 0;
      // check that angular momentum is correct.
      for (size_t alpha = 0; alpha < (size_t)n_orbitals; ++ alpha)
      {
	if (phi.get(alpha))
	{
	  theM += qnumbers[alpha].m;
	  theN += qnumbers[alpha].N;
	}
      }
      if (theM != M)
	return false;
  
      if (use_energy_cut && (theN > R))
	return false;


      return true;
      

    }

    /// \brief Check that the bais functions are all legal
    ///
    /// It checks that all Slater determinants have correct M, Sz and is inside
    /// the energy cut space; if applicable. We \em could use the constraint() function for this,
    /// but we want to give some messages about what's wrong when something is encountered.
    void checkBasis();

    /// \brief Return a reference to the Slater determinant basis.
    /// \return Reference to Slater determinant basis
    std::vector<manybody::Slater>& getSDBasis()
    {
      return sd_basis;
    }

    /// \brief Assign a Slater determinant basis
    /// 
    /// Typically called if the basis has been rearranged, pruned or similarly. (See manybody::CsfMachine.)
    /// \param new_basis   Reference to new Slater determinant basis
    void setSDBasis(std::vector<manybody::Slater>& new_basis)
    {
      size_t k;
      sd_basis.resize(new_basis.size());
      for (k = 0; k<new_basis.size(); ++k)
	sd_basis[k] = new_basis[k];

      // Assert that the new basis is okay!
      checkBasis();
    }

    /// \brief Print sd_basis to a MATLAB compliant array of structs.
    /// i.e., "basis(k+1) = struct('bin','0110101011000010', 'occ', [234 45 321  343....]);"
    ///
    void printBasis(std::ostream& os);



};



} // namespace quantumdot 

#endif
